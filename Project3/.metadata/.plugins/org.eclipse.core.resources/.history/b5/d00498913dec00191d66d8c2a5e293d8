package com.revdoc.service.impl;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;

import com.revdoc.dao.AvailableDAO;
import com.revdoc.model.Available;
import com.revdoc.service.UpdateAvailabilityService;

public class UpdateAvailabilityServiceImpl implements UpdateAvailabilityService {
	
	@Autowired
	private AvailableDAO dao;

	@Override
	public Available updateHours(Available time) {
		//This function needs to contain the functionality of getting the current availability on a given date,
		//checking to see if there are any overlaps in the old hours and new hours, remove the conflicting old hours,
		//and finally add in the new hours.
		
		//Gets all entries from the Availability Table
		List<Available> masterList= dao.findAll();
		
		for(Available block: masterList) {
			if(block.getDoctor()==time.getDoctor()&&block.getDate().equals(time.getDate())) {

				
				//Compare values to determine overlap. To prevent overlap, Start and End must be after end
				//or Start and ENd must be before Start. If there is an overlap, delete the block.
				if(!((block.getStart().before(time.getStart())&&block.getEnd().before(time.getEnd()))||(block.getStart().after(time.getEnd())&&block.getEnd().after(time.getEnd())))) {
					dao.delete(block);
				}
			}
		}
		
		dao.save(time);
		return time;
	}

	@Override
	public Available removeHours(Available time) {
		//This function needs to contain the functionality of getting the current availability on a given date,
		//checking to see if there are any overlaps in the two time periods, removing any conflicting overlaps.
		
		
		//get all entries from the Availability Table
		List<Available> masterList= dao.findAll();
		
		for(Available block: masterList) {
			if(block.getDoctor()==time.getDoctor()&&block.getDate().equals(time.getDate())) {

				
				//Compare values to determine overlap. To prevent overlap, Start and End must be after end
				//or Start and ENd must be before Start. If there is an overlap, delete the block.
				if(!((block.getStart().before(time.getStart())&&block.getEnd().before(time.getEnd()))||(block.getStart().after(time.getEnd())&&block.getEnd().after(time.getEnd())))) {
					dao.delete(block);
				}
			}
		}
		return time;
	}

}
